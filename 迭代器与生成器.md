# iterators & generators
- 迭代器是一个实现了迭代协议的容器对象

  对于 Python2.x 版本来说就是实现了 `__iter__ `和 `next `函数的对象类型；
  Python3.x 将 `next` 函数改成了`__next__`函数，以和其他内置的函数保持一致的双下划线风格。
  
  迭代协议要求`__iter__()`方法返回一个特殊的迭代器对象，由改该对象实现的`next()`方法来完成实际的迭代。
  
  迭代器的`next`方法，每次调用这个方法而实现计数，当然计数不是通过索引实现，调用了`next`方法后，迭代指针会指向下一个元素的位置。若下一个元素没有了，则会抛出`StopIteration`异常。

  实现的迭代器不需要准备所遍历的所有元素，这是迭代器的一大特性——惰性求值。

  如果一个对象实现了迭代器协议，则可以用 `for` 语句遍历这个对象的内容。其中` __iter__` 函数返回一个迭代器对象，而 `next` 函数则需要返回容器的下一个内容，如果没有下一个则抛出 `StopIteration` 异常，这个异常在` for ... in `语句中将会被捕获然后结束迭代。
  
- 创建定制的迭代器

  编写一个具有next方法的类，只要该类能够提供返回迭代器实例的__iter__特殊方法：
  
```
class MyIterator(object):
    def __init__(self, step):
        self.step = step
    def next(self):
    """Return the next element"""
        if self.step == 0:
            raise StopIteration
        self.step -= 1
        return self.step
    def __iter__(self):
    """Return the iterator iteself"""
        return self
```
```
for el in MyIterator(4):
    print(el)
    # 3, 2, 1, 0
```
---
        
- iter（object[, sentinel]) 函数

  Python标准库中对`iter`函数的描述
  return an iterator object.
  
  Without a second argument, object must be a __collection object__ which supports the iteration protocol (the` __iter__()` method), or it must support the sequence protocol (the` __getitem__()` method with integer arguments starting at 0). If it does not support either of those protocols, TypeError is raised.
  
  If the second argument, __sentinel__, is given, then object must be a __callable object__. The iterator created in this case will call object with no arguments for each call to its` __next__() `method; if the value returned is equal to sentinel, `StopIteration` will be raised, otherwise the value will be returned.
  
  One useful application of the second form of `iter() `is to read lines of a file until a certain line is reached. The following example reads a file until the` readline()` method returns an empty string:
```
  with open("mydata.txt") as fp:
      for line in iter(fp.readline, ''):
          process_line(line)
```
在涉及I/O处理的程序中，常常需要编写这样的代码：

```
CHUNKSIZE = 8192
def reader(s):
    while True:
        data = s.recv(CHUNKSIZE)
        if data = b'':
            break
        process_data(data)
```
这样的代码可以用iter()函数替换如下：

```
def reader(s):
    for data in iter(lambda: s.recv(CHUNKSIZE), b''):
        process_data(data)

```



Iterators themselves are a low-level feature and concept, and a program can live without them. But they provide the base for a much more interesting feature: __generators__.

---
