# 排序

如何评价一个排序算法：

- 执行效率。时间复杂度（系数，常数，低阶），比较次数和交换次数
- 内存消耗。原地排序（空间复杂度为 O(1)）
- 稳定性。经过排序之后，相等元素之间原有的先后顺序是否不变

## 冒泡排序

只操作相邻的两个数据，一次冒泡会让至少一个元素移动到它应该在的位置，当某次冒泡操作已经没有数据交换时，就说明已经达到完全有序了。

### 冒泡排序特点

- 原地排序，空间复杂度为 `O(1)`
- 是稳定的排序算法

时间复杂度分析，可通过 “有序度” 和 “逆序度” 这两个概念进行分析：

```code
# 有序元素对
a[i] <= a[j], 如果 i < j

# 逆序元素对
a[i] > a[j], 如果 i < j

逆序度 = 满有序度 - 有序度
```

冒泡排序包含两个操作：比较和交换。每交换一次，有序度就加 1，冒泡排序算法的交换次数为逆序度。平均时间复杂度为 `O(n2)`

## 插入排序

将数组中的数据分为两个区间：已排序区间和未排序区间，然后取未排序区间中的元素在已排序区间中找到合适的插入位置将其插入，保证已排序区间一直是有序的。重复这个过程直到未排序区间中的元素为空。

### 插入排序的特点

- 原地排序，空间复杂度为 `O(1)`
- 是稳定的排序算法
- 平均时间复杂度是 `O(n2)`

## 选择排序

选择排序也分已排序区间和未排序区间，每次从未排序区间中找到最小的元素，将其放到已排序区间的末尾 (与未排序区间的第一个元素交换)。

### 选择排序的特点

- 原地排序，空间复杂度为 `O(1)`
- 是不稳定的排序算法
- 平均时间复杂度是 `O(n2)`

## 归并排序

使用分而治之的思想，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起。

使用递归编写归并排序算法：

```code
# 递推公式
merge_sort(p, r) = merge(merge_sort(p, q), merge_sort(q+1, r))

# 终止条件
p >= r
```

### 归并排序的特点

- 是稳定的排序算法
- 时间复杂度是 `O(nlogn)`
- 非原地排序，空间复杂度是 `O(n)`

## 快速排序

快排利用的也是分治思想，但思路与归并排序完全不同。若要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot （分区点）。然后遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放在中间：

```code
# 递推公式
quick_sort(p, r) = quick_sort(p, q-1) + quick_sort(q+1, r)

# 终止条件
p >= r
```

为了避免额外的内存空间占用，需要实现原地分区函数 `partition`。

快排的核心思想就是分治和分区，可以运用快排的思想求解无序数组中的第 K 大元素。

### 快速排序的特点

归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快速排序的处理过程是由上到下的，先分区，然后再处理子问题。

- 非稳定排序。分区的过程涉及交换操作
- 原地排序
- 大部分情况下的时间复杂度为 `O(nlogn)`，极端情况下会退化到 `O(n2)`

## 堆排序

借助于堆这种数据结构实现的排序算法，就叫作堆排序。堆排序的过程可分解成两个步骤：

- 建堆，时间复杂度是 `O(logn)`
- 排序，时间复杂度是 `O(nlogn)`

技巧：将下标从 `n/2` 到 1 的节点依次进行从上往下的堆化操作。

### 堆排序的特点

- 非稳定排序，因为涉及到堆化交换的过程
- 原地排序
- 时间复杂度总是 `O(nlogn)`

在实际开发中，快速排序比堆排序性能要好，这是因为：

- 堆排序数据访问的方式没有快速排序友好（局部访问对 CPU 更友好）
- 对于同样的数据，堆排序的数据交换次数要多于快速排序

## 线性排序

线性排序的时间复杂度是线性的，是非基于比较的排序算法：

- 桶排序
- 计数排序
- 基数排序

### 桶排序

核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序，然后再把桶里的数据按照顺序依次取出，组成的序列就是有序的了。

#### 桶排序的特点

- 时间复杂度为 `O(n)`，（当桶的个数接近数据个数时）
- 桶排序对待排序数据的要求：
    - 待排序的数据需要很容易被划分到 M 个桶里
    - 桶与桶之间需要有天然的大小顺序
    - 数据在各个桶之间的分布是比较均匀的

#### 桶排序的适用场景

桶排序比较适合用在外部排序中，一个桶对应一个文件。

### 计数排序

计数排序可以认为是桶排序的一种特殊情况（桶内的每个值都是相同的，省掉了桶内排序的时间）。

计数排序的实现需要利用另外一个数组来计数，这也是计数排序名称的由来。

#### 计数排序的适用场景

只能用在数据范围不大的场景中，只能给非负整数排序

### 基数排序

使用基数排序时需要待排序的数据可以分割出独立的“位”来比较，而且位之间有递进关系，此外每一位的数据范围不能太大（可以用线性排序算法来排序）
