# 对 GraphQL 的评述

REST API 虽然简洁，每个 API 各司其职，但对客户端不友好，_为了获取所有用于渲染的数据，需要发出多个请求_。尤其是对于手机客户端，任何多余的请求都会大大拖累用户体验。

REST 在现实世界里遇到的诸多问题使 GraphQL 应运而生。作为一个 API 的查询语言，GraphQL 从产品的角度出发，希望 API 足够灵活能处理复杂多变的用户场景。

GraphQL 定义了一套完整的类型系统。服务器通过定义数据的类型告知客户端服务器的 capability，所以它也是一份 contract。GraphQL 还定义了一套严谨的查询语言。由此，GraphQL 可以很容易地通过类型系统和用户定义的 schema 生成强大的验证工具，保证 query 是正确的，且满足服务器的 capability。

GraphQL 的优势：

1. GraphQL 对于异构的数据源能够很好很简练地处理。GraphQL 很适合作为一层薄薄的 API gateway，成为客户端和各种内部系统（包括 REST API）的一个桥梁。

2. GraphQL 的客户端可以很灵活地在服务器能力范围内进行各种查询的组合，这种能力对向后兼容和版本控制很有好处。对于同一 API，服务器只需要添加新的 field，新的客户端查询时使用新的 field 即可，不会影响老客户端。

3. 对数据类型严格要求的 GraphQL 有助于减少类型不严格导致的问题。客户端可以放心大胆地根据事先给定的数据类型来使用服务端返回的结果，不必做许多额外的检查甚至是类型转换。

4. 良好的自说明性。使用 GraphQL 可以通过查询语句清晰、具体地描述这个请求的输入和输出。

使用 GraphQL 的注意事项：

1. 使用 GraphQL 并不意味着能提高 API 效率，GraphQL 只定义了 API 的 UI 部分，是否比 REST API 高效取决于实现的方式。因为 GraphQL 每个 field 单独 resolve，很容易出现 N+1 query。所以，在 resolve 的时候，一定要合理地使用 loader。

2. 使用 Relay 会给客户端和服务器都带来复杂性，如果刚开始使用 GraphQL，不建议直接引入 Relay。

3. GraphQL 的灵活性是把双刃剑。GraphQL 的查询能力隐含着很多安全上和性能上的问题，需要指定查询嵌套的上限，并且规定每个 API 的 timeout。

4. 使用 GraphQL 后旧有的缓存机制可能会失效。在 REST API 的世界，我们可以使用 nginx cache 或者 HA proxy 在 load balancer 级进行 API 的缓存 （如果 API 是幂等的）。但 GraphQL 的 query 都是以 POST 的方式提交，而 POST 并非幂等。

5. 使用 GraphQL 可能会增加实现的复杂度。原本的一些简单的 CRUD 的 API，在 GraphQL 下，变得复杂起来。

建议：

如果要采用 GraphQL，一定要注意要控制其灵活性，并做好性能的 benchmark。如果想要将已有的 API 系统迁移到 GraphQL，初期可以使用 GraphQL 包装已有的 REST API，让客户端工程师尽情试验。随后再根据重要性和紧迫程度逐步一个个重写已有的 API，切忌一上来就全部推倒重写。


REST 在实际使用中的问题：

1. 数据定制的问题。数据的返回可能很丰富，非常大，而我这次可能只要其中一小部分。虽然可以加个 Mask 参数解决，但是不够灵活。

2. 多次请求的问题。如果一次想多要些数据，往往我们就不得不使用多次的请求（为了渲染一个页面需要串行发起多个请求）。

3. 异常处理的问题。不同程序员的实现可能都不太一样，没有统一的更结构化的异常处理方式。

4. 发出一个请求，不能确定会得到什么返回结果。你可能需要查阅文档，但文档可能已经过期。你可以自己实验，但你不知道是否覆盖了全部可能的情况。。。

5. PUT 和 DELETE 需要前后端框架的支持。需要尽量避免使用 PUT 和 DELETE 来设计 API

6. 每个 resource 都有自己的一组 end point （URL），这会带来管理和维护的麻烦。

7. Rest 难以避免的从 URL 上接受各种参数（parameter），不严格的使用 GET 等都会造成安全的隐患。


GraphQL 的性能：

使用 GraphQL，不再是 restful 那种一个一张表的简单情况了。优化很重要，做的好就不会增加后端查询的复杂度。

GraphQL 是很轻薄的一层，它自己额外产生的延迟（Overhead）是很低的。问题的关键是 GraphQL 会不会额外产生过多数据库的查询。这个担心是有道理的，如果给每一个字段都上一个 resolver 函数，函数里直接执行数据库查询，那当然会产生非常多的查询。

目前已有的 GraphQL 后端实现已经提供了非常灵活的自定义优化方式，比如可以结合使用 Cache 和 Context 对象来减少数据库查询次数。

使用 GraphQL 可以通过各种嵌套来达成你的查询目的，数据也不再是单一的资源，而形成了一个图，这是一种 _图形化的查询_。

对于前端来说，你有什么样的 view, 需要什么样的数据，你就构建什么样的请求，得到的结果你就可以直接用来生成和填充你的 view。再复杂的 view 你也可以一次查询请求搞定，这对前端的反应速度和开发效率是个巨大的提升。


## 关于 graphql python

- 提供十分方便的自定义功能，从解析到查询到处理结果，都能够自定义
- 有 Dataloader 功能，能解决 N+1 问题
- 与流行框架有现成的集成扩展 `graphene-django`、`flask-graphql` 以及通用的 `graphene-sqlalchemy`
- 支持复杂的 Relay 查询
- 支持复杂的 Connection 查询，能实现分页的功能
- 支持 NoSQL、MySQL 甚至直接支持 Python 对象作为数据源
- 最大的缺点是，文档写得太简单了，高级用法全得靠自己摸索
