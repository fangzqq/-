# 垃圾回收

一句话总结： 在 CPython 中,垃圾回收使用的主要算法是 引用计数。每个对象都会统计有多少个对象指向自己，当对象的引用数量归零后，对象会立即被销毁。CPython 2.0 增加了 分代垃圾回收算法, 用于检测引用循环中涉及的对象组——如果一组对象之间全是相互引用, 即使它们各自的引用计数不为零也将导致组中的对象不可获取。因此，如果除了循环引用之外没有其他引用, 两个对象都会被销毁。

## 引用计数

实现简单，具备实时响应能力。引用计数的缺点是：

- 维护引用计数需要消耗资源
- 不能处理含有循环引用的数据结构

## 标记-清除与分代收集

标记-清除算法是现在垃圾回收算法的思想基础。标记清除算法将垃圾回收分为两个阶段：

- 标记阶段
    - 首先通过根节点，标记所有从根节点开始的可达对象
    - 未被标记的对象就是未被引用的垃圾对象
- 清除阶段
    - 清除未被标记的对象

这是一种基于追踪回收技术实现的垃圾回收算法。Python 使用了些许标记清除的思想来处理循环引用

### 分代收集

Generational Garbage Collection

弱代假说, weak generational hypothesis:

- 新创建的对象通常死得也快
- 老对象则可能存活更长的时间

python 使用链表来持续追踪活跃的对象，Python 内部称之为零代链表（Generation Zero）。这个链表是一个完全内部的 Python 运行时，不能直接在代码中访问。

每当创建一个对象时，python 便会将其加入零代链表。随后， Python 会循环遍历零代链表上的每个对象，检查链表中每个互相引用的对象，根据规则减掉其引用计数。在这个过程中，Python 会一个接一个的统计内部引用的数量以防过早地释放对象。

通过识别内部引用，Python 能够减少许多零代链表对象的引用计数。若零代链表对象的引用计数减少到零，这意味着收集器可以释放它们并回收内存空间了。剩下的活跃的对象则被移动到一个新的链表：一代链表。

#### Python 中的 GC 阈值

Python 什么时候会进行这个检测过程呢？ 当 __被分配对象的计数值__ 与 __被释放对象的计数值__ 之间的差异累计超过某个阈值，则 Python 的检测收集机制就启动了。

随着时间的推移，程序所使用的对象逐渐从零代链表移动到一代链表。而 Python 对于一代链表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python 会将剩下的活跃对象移动到二代链表。

通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python 可以在不同的时间间隔处理这些对象。Python 处理零代最为频繁，其次是一代然后才是二代。

通过频繁的处理零代链表中的新对象，Python 的垃圾收集器将把时间花在更有意义的地方：它处理那些很快就可能变成垃圾的新对象。同时只在很少的时候，当满足阈值的条件，收集器才去处理那些老变量。

---

del 语句删除名称,而不是对象。del 命令可能会导致对象被当作垃圾回收,但是仅当删除的变量保存的是对象的最后一个引用,或者无法得到对象时。

### 弱引用

弱引用不会增加对象的引用数量。引用的目标对象称为 _所指对象(referent)_ 。因此我们说,弱引用不会妨碍所指对象被当作垃圾回收。

某些情况下,可能需要保存对象的引用,但不留存对象本身。例如,有一个类想要记录所有实例。这个需求可以使用弱引用实现,这是一种低层机制,是 `weakref` 模块中 `WeakValueDictionary` 、`WeakKeyDictionary` 和
`WeakSet` 等有用的集合类,以及 `finalize` 函数的底层支持。

弱引用在缓存应用中很有用,因为我们不想仅因为被缓存引用着而始终保存缓存对象。
