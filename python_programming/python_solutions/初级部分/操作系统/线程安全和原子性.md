# 操作系统

## 线程安全和原子性

### 线程安全

线程安全是应用于多线程程序中的概念。线程安全的代码在操作共享数据时，可以保证所有的线程行为正常，并满足设计要求，而没有 _非预期的行为_。

线程安全是一种特性，即通过在实际的控制流和程序文本之间重建（re-establish）一些通信机制（使用同步机制），允许代码在多线程环境中运行

#### 线程安全的等级

- 线程安全，多个线程同时执行时（获取共享数据时）不会有竞争条件发生
- 有条件的安全（conditionally safe），不同的线程可以同时获取不同的对象，当获取共享数据时，被保护起来，不受竞争条件影响
- 不是线程安全

在考虑线程安全时，应注意的问题：
- 避免或减少发生死锁的可能
- 要最大化程序的并发性能


#### 竞争条件

竞争条件是指多个线程或进程在读写一个共享数据时，结果 _依赖于它们执行的相对时间_的情形。

竞争条件发生在当多个线程或进程在读写一个共享数据时，最终的结果依赖于多个进程的指令执行顺序。

由竞争条件产生的 bug 不易重现和 debug, 这是因为：
- 最终结果是不确定的
- 生产环境中产生的问题在 debug 模式可能会消失

因此，应该提前做好软件设计，避免竞争条件发生。


#### 避免竞争条件

通过避免竞争条件，可以达到线程安全的目的。有两种方法可以避免竞争条件：
1. 不同线程间避免共享状态:
    - Re-entrancy，这要求程序可以在执行途中中断，然后把状态信息保存在每个执行线程中的局部变量里（栈），后续可以继续执行。所有对非局部状态的操作都必须是原子操作，程序使用的数据结构也必须是可重入的。
    - Thread-local-storage，变量在局部作用域，每个线程都私一份自己的拷贝。
    - immutable objects，对象在创建以后，状态不可改变。这也意味着只有只读型的数据是共享的，可变类型的操作可以通过创建新对象而不是修改现存的对象实现
2. 当共享状态不可避免时，使用同步机制
    - Mutual exclusion（互斥条件），在任何时候只允许一个线程对共享数据进行读或写操作。如果使用不当会导致 _deadlock，livelock 和 资源饥饿_
    - 原子操作，使用不能被其他线程中断的原子操作进行数据的读写。这通常需要使用特殊的机器语言指令。原子操作是很多线程锁机制的基础，用于 _实现互斥条件原语_。


#### 理解 Thread-local storage 

TLS 是一种编程方法，让给定的多线程进程中的每个线程可以使用这种方法分配用以存储线程特定的数据的位置。

线程局部存储的使用场景：
- 一个变量看起来好像是全局变量，但实际上每个线程都有一份私有的拷贝（即使变量名相同，但每个线程中这个变量的值可以不同）
- 用于避免竞争条件

很多 os 对线程局部存储的尺寸有要求。


同一进程的不同线程间资源是共享的，而线程的调度是由操作系统完成的。由于多线程在执行时存在线程的切换，而 _线程的切换是抢占式的_，切换时机不可控。因此，如果对多个线程访问同一个可变的状态变量时没有使用合适的同步操作，那么程序就可能出现错误。因此，使用多线程时有必要对 _共享且可变的状态数据_ 进行管理，这也就是线程安全的问题。


## 原子性

原子性，也叫 linearizable，indivisible，uninterruptible。这个概念与线程安全和可重入性有关。

### 什么是原子操作

原子本意是指“不能被进一步分割的最小粒子”，而原子操作（atomic operation）则是指“不可被中断的一个或一系列操作”。

### 原子操作的特点

原子操作要么一次全部都执行，要么全部都不执行，而不存在执行了一半却被中断的情况。

### 为什么需要原子操作

在线程中使用原子操作可以保证操作不被中断，也就保证了线程安全。

## 如何保证原子操作

通过互斥条件，可以实现原子操作。

Python 使用锁机制可以实现原子操作，锁机制保证了只有获得锁的线程能够操作锁定的内存区域
