

## 内存泄露

程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。

对于 _持续运行的服务进程_ （daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

不再用到的内存，没有及时释放，就叫做 _内存泄漏（memory leak）_ 。有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。手动管理内存很麻烦也不安全，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为"垃圾回收机制"（garbage collection）。

实际上，只有开发者自己可以搞清楚一块内存是否应该被操作系统回收，垃圾回收机制并不能完全保证内存对象在该释放的地方释放，垃圾回收机制只是会减少内存泄露的机会。

## python 中的内存泄露实例

项目中内存泄露的可能原因：

- 存在只有在程序退出时才会回收的对象引用
  - _全局变量_ 和 _类变量_ 都只在程序退出时才会被回收
- 交叉引用
  - 交叉引用只能靠分代回收机制的 2 代和 3 代回收，这个过程可能会很慢


### 因全局变量或类变量使用不当产生的内存泄露

内存泄露场景一

对于一个 TCP server, 每当有连接过来时都会创建一个连接实例来进行管理, 每次断开时 _连接实例还被占用并没有释放_. 随着时间的推移, 连接创建分配内存, 连接断开并没有释放掉内存, 就会产生内存泄露。

具体看如下代码片段：

```python
_CONNECTIONS = []

# ...
class Connection(object):
    def __init__(self, sock, address)
        pass

def server_loop():
    # ...
    sock, address = server_sock.accept()
    connection = Connection(sock, address)
    _CONNECTIONS.append(connection)
    # ...
    sock.close()
```

上面把所有建立的连接都放在全局变量 `_CONNECTIONS` 里, 如果在关闭连接的时候不从这个列表里取出(减少引用)则 connection 对象就不会被回收, 则每建立一次连接就会有个新的连接对象和这个新的连接对象同样被放在 `_CONNECTIONS` 里 不会被回收。

如果把连接对象放在一个类属性里也是一样的, 因为类对象在程序一开始就分配, 并在程序退出时才被回收。

这种内存泄露问题的解决办法就是在退出时从列表(或其他对象)里解除对对象的引用(删除)：

```python
_CONNECTIONS = []

# ...
class Connection(object):
    def __init__(self, sock, address)
        pass

def server_loop():
    # ...
    sock, address = server_sock.accept()
    connection = Connection(sock, address)
    _CONNECTIONS.append(connection)
    try:
        # ...
        sock.close()
    finally:
        _CONNECTIONS.remove(connection) # 删除引用
```


内存泄露场景二

下面看一个由 logging 模块误用导致的内存泄露案例。

对于每一个连接，为了让日志输出当前连接的信息, 为每一个连接都创建一个日志实例, 创建的日志实例为了区分其他连接，使用当前对象的 id 来作为日志名称。具体如下所示：

```python
import logging


class Connection(object):
    def __init__(self):
        self._logger_name = "Connection.{}".format(id(self))
        self.logger = logging.getLogger(self._logger_name)
```

但是这样做将会产生内存泄露，这是因为 logging 模块为了保证同一个名称引用同一个日志实例, 就把所有的日志实例全部存在了一个 `loggerDict` 的字典里, 所以除非程序退出, 创建的日志实例引用是不会释放的, 所以日志实例里的 handlers 也不会释放。

为了解决这个问题可以在连接关闭的时候加入如下代码:

```python
logging.Logger.manager.loggerDict.pop(self._logger_name)
self.logger.manager = None
self.logger.handlers = []
```


### 因交叉引用而产生的内存泄露

有时候我们为对象分配一个实例属性时需要将这个对象本身赋值给实例属性, 具体看如下代码:

```python
class ConnectionHandler(object):
    def __init__(self, connection):
        self._conn = connection


class Connection(object):
    def __init__(self, sock, address)
        self._conn_handler = ConnectionHandler(self) # 将自身赋值给实例属性
```

上面的代码就会产生交叉引用, 解决这种问题的方法就是使用 _弱引用_:

```python
import weakref

class ConnectionHandler(object):
    def __init__(self, connection):
        self._conn = connection


class Connection(object):
    def __init__(self, sock, address)
        self._conn_handler = ConnectionHandler(weakref.proxy(self)) # 使用弱引用
```
