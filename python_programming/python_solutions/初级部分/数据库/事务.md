# 数据库

## 事务

一个数据库事务通常包含对数据库进行读或写的 _一个操作序列_， 可以被看作一个单元的一系列 SQL 语句的集合。事务的概念来自于两个独立的需求：并发数据库访问，系统错误恢复。详细的说：

1. 为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
2. 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

当一个事务被提交给了 DBMS（数据库管理系统），则 DBMS 需要确保: 
- 该事务中的所有操作都成功完成且其结果被永久保存在数据库中，或者
- 如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）
- 同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行

在现实情况下，事务操作失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要 DBMS 对一个执行失败的事务执行恢复操作，将其数据库状态恢复到 _一致状态_ （数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS 通常需要 _维护事务日志_ 以追踪事务中所有影响数据库数据的操作。

## 事务的四大特性

并非任意的对数据库的操作序列都是数据库事务。事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性:

- 原子性（Atomicity）。事务作为一个整体被执行，包含在其中的对数据库的操作要么全部成功，要么全部失败回滚。
  - 通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。
- 一致性（Consistency）。事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是 _数据库中的数据应满足完整性约束_。
  - 拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性
- 隔离性（Isolation）。多个事务并发执行时，一个事务的执行不应影响其他事务的执行，多个并发事务之间要相互隔离。
  - 事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务 _不会查看中间状态的数据_。换句话说，一个事务的影响在该事务提交前对其他事务都不可见。
  - 关于事务的隔离性，数据库提供了多种隔离级别
- 持久性（Durability）。一个事务一旦提交，则该事务对数据库的修改应该永久保存在数据库中。

## 事务的隔离级别

如果不对数据库进行并发控制，可能会产生异常情况，具体包括：

- 脏读(Dirty Read)。当一个事务读取另一个事务尚未提交的修改时，产生脏读。
  - 一个事务开始读取了某行数据，但是另外一个事务 _已经更新了此数据但没有能够及时提交_。这是相当危险的，因为很可能所有的操作都被回滚，也就是说读取出的数据其实是错误的。
  - 同一事务内不是脏读
- 非重复读(Nonrepeatable Read)。一个事务对同一行数据重复读取两次，但是却得到了不同的结果。
  - 同一查询在同一事务中多次进行，由于在查询间隔其他提交事务 _做了修改或删除操作_，导致每次返回不同的结果集，此时发生非重复读。
  - 脏读是某一事务读取了另一个事务未提交的脏数据；而非重复读则是读取了前一事务提交的数据
- 幻读(Phantom Reads)。事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的 SQL 语句相同）。
  - 这种情况是因为在两次查询过程中有另外一个事务插入数据造成的。当对某行执行 _插入或删除操作_，而该行属于某个事务正在读取的行的范围时，会发生幻读问题。
  - 幻读和非重复读都是读取了另一条已经提交的事务，不同的是非重复读查询的都是同一个数据项，而幻读针对的是一批数据整体
- 丢失修改(Lost Update)。这可分为两类情况：
  1. 当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。
  2. 有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成 _第一次写操作失效_。

为了兼顾 _并发效率和异常控制_，在标准 SQL 规范中，定义了 4 个事务隔离级别，（ Oracle 和 SQL Server 对标准隔离级别有不同的实现 ）：

- 未提交读(Read Uncommitted)。直译就是"读未提交"，意思就是 _即使一个更新语句没有提交，但是别的事务可以读到这个改变_。因此，Read Uncommitted 允许脏读。
- 已提交读(Read Committed)。直译就是"读提交"，意思就是 _语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变_，只能读取到已经提交的数据。Oracle 等多数数据库默认都是该级别。因此，Read Commited 不允许脏读，但会出现非重复读。
- 可重复读(Repeatable Read)。直译就是"可以重复读"，这是说 _在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的_。因此，Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。
- 串行读(Serializable)。直译就是"序列化"，意思是说 _这个事务执行的时候不允许别的事务并发执行_。完全串行化的读，每次读都需要获得 _表级共享锁_，读写相互都会阻塞。 因此， Serializable 不允许不一致现象的出现。

在 MySQL 数据库中，支持上面四种隔离级别，默认的为 Repeatable read (可重复读)；而在 Oracle 数据库中，只支持 Serializable (串行化)级别和 Read committed (读已提交)这两种级别，其中默认的为 Read committed 级别。

在 MySQL 数据库中查看当前事务的隔离级别：

```sql
SELECT @@tx_isolation;
```

在MySQL数据库中设置事务的隔离级别：

```sql
SET tx_isolation='read-uncommitted';
```

## 事务隔离的实现——锁

### 共享锁(S 锁)

用于只读操作(`SELECT`)，锁定共享的资源。共享锁不会阻止其他用户读，但是会 _阻止其他的用户写和修改_。

### 更新锁(U 锁)

用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。

### 独占锁(X 锁，也叫排他锁)

一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁，包括共享锁。_写是独占锁_，可以有效的防止“脏读”。


Read Uncommited 如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。

Read Committed 读取数据的事务允许其他事务继续访问该行数据，但是 _未提交的写事务将会禁止其他事务访问该行_。可以通过“瞬间共享读锁”和“排他写锁”实现。

Repeatable Read 读取数据的事务将会 _禁止写事务（但允许读事务）_，写事务则 _禁止任何其他事务_。可以通过“共享读锁”和“排他写锁”实现。

Serializable 读加 _共享锁_，写加 _排他锁_，读写互斥。
