# 数据库

## 数据库索引

什么是数据库索引？

MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。也就是说，索引是 _一种数据结构_。

为什么需要数据库索引？

数据库查询是数据库的最主要功能之一，我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从 _查询算法_ 的角度进行优化。因为每种查找算法都只能应用于特定的数据结构之上，例如：

- 二分查找要求被检索的数据有序
- 而二叉树查找只能应用于二叉查找树上

因此，在数据之外，数据库系统还需要维护着满足 _特定查找算法的数据结构_，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

合理的使用数据库索引，能够大大提高系统的性能：

- 通过创建唯一性的索引，可以保证数据库表中每一行数据的唯一性。
- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
- 在使用 _分组和排序_ 子句进行数据检索时，同样可以显著的减少查询中分组和排序的时间。
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

同时增加索引也有一些不利的方面：

- 创建索引和维护索引需要消耗时间，这种时间随着数量的增加而增加。
- 索引需要占物理空间，除了数据表占据数据空间之外，每一个索引还要占一定的物理空间，如果要建立 _聚簇索引_，那么需要额空间就会更大。
- 当对表中的数据进行增加，删除和修改的时候，索引也要 _动态的维护_，这样就降低了数据的维护速度。

## 索引的原理

### B-Tree 和 B+Tree

B-Tree 或其变种 B+Tree 是一种经典的索引结构。MySQL 就普遍使用 B+Tree 实现其索引结构。

为什么说 B+Tree 是数据库系统实现索引的首选数据结构？

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以 _索引文件_ 的形式存储在磁盘上。

这样的话，索引查找过程中就要产生 _磁盘 I/O_ 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是 _在查找过程中磁盘 I/O 操作次数的渐近复杂度_。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。

B-/+Tree 索引的性能分析

根据 B-Tree 的定义，可知检索一次最多需要访问 h （树高）个节点。数据库系统的设计者巧妙利用了 _磁盘预读原理_，将一个节点的大小设为等于 _一个页_，这样 _每个节点只需要一次 I/O 就可以完全载入_。

B-Tree 中一次检索最多需要 `h-1` 次 I/O（根节点常驻内存），渐近复杂度为 `O(h)=O(logdN)`。

一般实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过 3）。因此用 B-Tree 作为索引结构效率是非常高的。

与 B-Tree 相比，B+Tree 更适合 _外存索引_，原因和内节点出度 d 有关。从上面分析可以看到，d 越大索引的性能越好，而出度的上限取决于节点内 key 和 data 的大小：

```code
dmax = floor(page_size/(key_size + data_size + point_size))
```

由于 B+Tree 的 _枝节点去掉了 data 域_，因此可以拥有更大的出度，拥有更好的性能。

## MySQL 的索引实现

在 MySQL 中，索引是属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，我们主要讨论 MyISAM 和 InnoDB 两个存储引擎的索引实现方式。

### MyISAM 引擎

MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是 _数据记录的地址_。

在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 _key 是唯一的_，而辅助索引的 _key 可以重复_。

因此，MyISAM 中索引检索的算法为：

- 首先按照 B+Tree 搜索算法搜索索引，
- 如果指定的 Key 存在，则取出其 data 域的值，
- 然后以 data 域的值为地址，读取相应数据记录

### InnoDB 引擎

InnoDB 也使用 B+Tree 作为索引结构，但具体实现方式却与 MyISAM 截然不同：

- InnoDB 的数据文件本身就是索引文件。从上文知道，MyISAM 索引文件和数据文件是 _分离的_，索引文件仅保存 _数据记录的地址_。而在 InnoDB 中，_表数据文件本身就是按 B+Tree 组织的一个索引结构_，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的 _主键_，因此 InnoDB 表数据文件本身就是主索引。
  - InnoDB 使用的 B+Tree 叶节点包含了完整的数据记录。这种索引叫做 _聚集索引_。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整形
- InnoDB 的辅助索引 data 域存储相应记录 _主键的值而不是地址_。换句话说，InnoDB 的所有辅助索引都 _引用主键作为 data 域_

InnoDB 使用的聚集索引这种实现方式使得 _按主键的搜索十分高效_，但是使用辅助索引搜索时需要 _检索两遍索引_：

1. 首先检索辅助索引获得主键
2. 然后用主键到主索引中检索获得记录


## 索引的分类

### 从数据结构角度进行分类

-  B+Tree 索引
- hash 索引
  - 仅仅能满足 "=","IN" 和 "<=>" 查询，不能使用范围查询
  - 其检索效率非常高，索引的检索可以一次定位，不像 B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的 I/O 访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引
  - 只有 Memory 存储引擎显试支持 hash 索引
- FULLTEXT 索引 ( MyISAM 和 InnoDB 引擎都支持了)
- R-Tree索引（用于对 GIS 数据类型创建 SPATIAL 索引）

### 从物理存储角度进行分类

- 聚簇索引（clustered index）
- 非聚簇索引（non-clustered index）

### 从逻辑角度进行分类

- 主键索引
  - 主键索引是一种特殊的唯一索引，不允许有空值
- 唯一索引
  - 唯一性索引保证 _在索引列中的全部数据是唯一的_，不会包含冗余数据，允许出现空值
- 普通索引
  - 普通索引(由关键字 `KEY` 或 `INDEX` 定义的索引)的唯一任务是加快对数据的访问速度。
  - 应该只为那些最经常出现在查询条件（`WHERE`）或排序条件(`ORDER BY`)中的数据列创建普通索引。
  - 只要有可能，就应该选择一个数据最整齐、最紧凑的数据列(如一个整数类型的数据列)来创建普通索引。
- 外键索引
  - 如果为某个外键字段定义了一个 _外键约束条件_，MySQL 就会定义一个内部索引来帮助自己以最有效率的方式去管理和使用外键约束条件，这就是外键索引
- 复合索引（多列索引）
  - 复合索引就是 _一个索引创建在两个列或者多个列上_。复合索引可以减少一在一个表中所创建的索引数量。
  - 只有在查询条件中使用了创建复合索引时的 _第一个字段_，索引才会被使用。使用复合索引时遵循 _最左前缀集合_
- 空间索引
  - 空间索引是对空间数据类型的字段建立的索引，MYSQL 中的空间数据类型有4种
    1. GEOMETRY
    2. POINT
    3. LINESTRING
    4. POLYGON
  - MYSQL 使用 SPATIAL 关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为 NOT NULL
  - 空间索引只能在 MYISAM 存储引擎中创建


###  创建索引的方法

- 直接创建
- 间接创建（在表中定义主键约束或者唯一性约束时，同时也创建了索引）

在绝大多数应用里，数据库中的字符串数据大都以各种各样的名字为主，把索引的长度设置为 10~15 个字符已经足以把搜索范围缩小到很少的几条数据记录了。

在为 BLOB 和 TEXT 类型的数据列创建索引时，必须对索引的长度做出限制；MySQL 所允许的最大索引长度是 255 个字符。


## 索引使用策略及优化

了解了不同存储引擎的索引实现方式对于 _正确使用和优化索引_ 都非常有帮助，例如：

- 知道了 InnoDB 的索引实现后，就很容易明白为什么 _不建议使用过长的字段作为主键_，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。
- 用 _非单调的字段_ 作为主键在 InnoDB 中不是个好主意，因为 InnoDB 数据文件本身是一颗 B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整，十分低效，而使用 _自增字段_ 作为主键则是一个很好的选择。

MySQL 的优化主要分为：

- 结构优化（Scheme optimization）
- 查询优化（Query optimization）

### 结构优化

我们讨论的高性能索引策略主要属于 _结构优化_ 范畴。实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。

#### 最左前缀原理与相关优化

高效使用索引的首要条件是知道 _什么样的查询会使用到索引_，这个问题和 B+Tree 中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。

在继续讨论之前，首先需要理解 _复合索引_ 的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL 中的索引可以 _以一定顺序引用多个列_，这种索引叫做复合索引。

一般的，一个复合索引是一个有序元组 `<a1, a2, …, an>` ，其中各个元素均为数据表的一列。_单列索引_ 可以看成复合索引元素数为 1 的特例。

下面以 employees.titles 表为例，下面先查看其上都有哪些索引：

```
SHOW INDEX FROM employees.titles;
+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+
| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |
+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+
| titles |          0 | PRIMARY  |            1 | emp_no      | A         |        NULL |      | BTREE      |
| titles |          0 | PRIMARY  |            2 | title       | A         |        NULL |      | BTREE      |
| titles |          0 | PRIMARY  |            3 | from_date   | A         |      443308 |      | BTREE      |
+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+
```

情况一： 全列匹配

```
EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title='Senior Engineer' AND from_date='1986-06-26';
+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+
| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |
+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+
|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |
+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+
```


当按照联合索引对所有列进行 _精确匹配_（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于 MySQL 的查询优化器会自动调整 `where` 子句的条件顺序以使用适合的索引，因此实际上效果是一样的。


情况二：最左前缀匹配

```
EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001';
+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+
| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra |
+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+
|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |       |
+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+
```

当查询条件精确匹配索引的 _左边连续一个或几个列_ 时，索引可以被用到，但是只能用到一部分索引，即由匹配条件所组成的 _最左前缀_ 。


情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供

```
EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND from_date='1986-06-26';
+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+
| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |
+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+
|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |
+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+
```

由于中间索引 `title` 不存在而无法和左前缀 `emp_no` 连接，将导致后面的索引 `from_date` 不起作用。解决方法：

- 增加一个辅助索引, `< "emp_no", "from_date">`
- 使用 "隔离列" 方法进行优化，将中间的“坑”填上
  - 若中间索引所在的列，只有几种不同的值时，可以考虑使用 "IN" 来填补这个“坑”，从而形成最左前缀


情况四：查询条件没有指定索引（最左）第一列

```
EXPLAIN SELECT * FROM employees.titles WHERE from_date='1986-06-26';
+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |
+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+
```

由于不是最左前缀，这样的查询显然用不到索引。


情况五：匹配某列的前缀字符串

```
EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title LIKE 'Senior%';
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 56      | NULL |    1 | Using where |
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
```

此时可以用到索引（如果通配符 `%` 不出现在开头，则可以用到索引，但根据具体情况不同可能只会用到其中一个前缀）


情况六：范围查询

```
EXPLAIN SELECT * FROM employees.titles WHERE emp_no < '10010' and title='Senior Engineer';
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
```

范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。使用 MySQL 仅用 explain 可能无法区分 _范围查询_ 和 _多值匹配_，因为在 type 中这两者都显示为 range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：

```
EXPLAIN SELECT * FROM employees.titles
WHERE emp_no BETWEEN '10001' AND '10010'
AND title='Senior Engineer'
AND from_date BETWEEN '1986-01-01' AND '1986-12-31';
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |   16 | Using where |
+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+
```

上面看起来是用了两个范围查询，但作用于 `emp_no` 上的 “BETWEEN” 实际上相当于 “IN”，也就是说 `emp_no` 实际是 _多值精确匹配_。可以看到这个查询用到了索引全部三个列。因此在 MySQL 中要谨慎地区分多值匹配和范围匹配，否则会对 MySQL 的行为产生困惑。


情况七：查询条件中含有函数或表达式

如果查询条件中含有函数或表达式，则 MySQL 不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：

```
EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND left(title, 6)='Senior';
+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+
| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |
+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+
|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |
+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+
```

再如：

```
EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1='10000';
+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |
    +----+-------------+--------+------+---------------+------+---------+------+--------+-------------+
```

显然这个查询等价于查询 `emp_no` 为 10001 的所有记录，但是由于查询条件是一个表达式，MySQL 无法为其使用索引。因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。


#### 索引选择性与前缀索引

索引虽然加快了查询速度，但索引也是有代价的：

- 索引文件本身要消耗存储空间，
- 同时索引会加重插入、删除和修改记录时的负担，
- 另外，MySQL 在运行时也要消耗资源维护索引

因此索引并不是越多越好，以下情况不建议建索引：

- 在查询中很少使用或者作为参考的列不应该创建索引。
- 对于那些只有很少数据值的列也不应该增加索引（索引的选择性较低）。
- 对于那些定义为 `text`，`image` 和 `bit` 数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
- 当修改性能远远大于检索性能时，不应该创建索引，因为修改性能和检索性能是矛盾的。

所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：

```code
Index Selectivity = Cardinality / #T
```

显然选择性的取值范围为 (0, 1]，_选择性越高的索引价值越大_，这是由 B+Tree 的性质决定的。例如，上文用到的 `employees.titles` 表，如果 title 字段经常被单独查询，是否需要建索引，我们看一下它的选择性：

```code
SELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles;
+-------------+
| Selectivity |
+-------------+
|      0.0000 |
+-------------+
```

title 的选择性不足 0.0001，所以实在没有什么必要为其单独建索引。

有一种与索引选择性有关的索引优化策略叫做 _前缀索引_，就是用列的前缀代替整个列作为索引 key，当前缀长度合适时，可以做到：
- 既使得前缀索引的选择性接近全列索引，
- 同时因为索引 key 变短而减少了索引文件的大小和维护开销

前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于 `ORDER BY` 和 `GROUP BY` 操作，也不能用于 `Covering index`（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。

#### InnoDB 的主键选择与插入优化

在使用 InnoDB 存储引擎时，如果没有特别的需要，应该永远使用一个 _与业务无关的自增字段_ 作为主键。

上文讨论过 InnoDB 的索引实现，InnoDB 使用聚集索引，数据记录本身被存于主索引（一颗 B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为 _一个内存页或磁盘页_）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL 会根据其主键将其插入适当的节点和位置，如果页面达到 _装载因子_（InnoDB 默认为15/16），则开辟一个新的页（节点）。

如果表使用自增主键，那么每次插入新的记录时，记录就会 _顺序添加到当前索引节点的后续位置_，当一页写满，就会自动开辟一个新的页。这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。

如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值 _近似于随机_，因此每次新纪录都要被插到现有索引页的中间某个位置。这种情况下 MySQL 不得不：

- 为了 _将新记录插到合适位置而移动数据_，
- 甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，
- 同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE 来重建表并优化填充页面。

所以说，请尽量在 InnoDB 上采用自增字段做主键。




与排序（ORDER BY）相关的索引优化

覆盖索引（Covering index），

除B-Tree索引外 MySQL 还根据不同引擎支持的哈希索引、全文索引




## 总结

### 建立索引的原则

应该对如下的列建立索引：

- 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。
- 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。
- 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。
- 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- 在经常使用在 `where` 子句中的列上面创建索引，加快条件的判断速度。

有些列不应该创建索引:

- 在查询中很少使用或者作为参考的列不应该创建索引。
- 对于那些只有很少数据值的列也不应该增加索引（索引的选择性较低）。
- 对于那些定义为 `text`，`image` 和 `bit` 数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
- 当修改性能远远大于检索性能时，不应该创建索引，因为修改性能和检索性能是矛盾的